##
# Setup File Template.
# Generated by ATEGen (Version 1.10.8-3 [linux x86_64] 25-Nov-2020).
# (c) Copyright 1998-2022 Test Insight Ltd.
##

##############################
# Input File Definition
# Notes:
# - STIL, WGL, SVF, TDL91 and AIF file types are supported
# - file type is determined automatically by content (except AIF)
# - force file type by setting input_file_type value below (automatic recognition is disabled)
##
input_file_type = 'STIL'     # valid values: STIL WGL TDL SVF AIF (optional if not AIF)

##############################
# Mask failures file
# If the parameter is not empty, mask failures in STIL pattern
#  - read vectors, mask failing signals/cycles according to informastion from failures file
#  - create masking waveforms for relevant signals
# Each line of failures file should contain
#   cycle number, signal name, expected data and actual data separated by tabs
##
#mask_failing_signals = 'path'

##############################
# Fix failures file
# If the parameter is not empty, fix failures in STIL pattern
#  - read vectors, fix failing signals/cycles according to informastion from failures file
#  - create masking waveforms for relevant signals
# Each line of failures file should contain
#   cycle number, signal name, expected data and actual data separated by tabs
##
#fix_failing_signals = 'path'

##############################
# Keep intermediate STIL files (Optional)
keep_stil_files = 0

################################
# 93000 AIF Reader Configuration
######

# Specifies AIC file (Mandatory)
aic_file = ''

# Specifies DVC file (Mandatory)
dvc_file = ''

# Specifies 93000 Pin Configuration file (Optional, may be defined in AIC)
pins_file = ''

# Specifies default AVC files directory (Optional, may be defined in AIC)
avc_dir = ''

##############################
# WGL Reader Configuration
######

# Scan input padding value. (Optional)
# Valid values are: [01XZ]
wgl_scan_in_padding = '0'

# Scan output padding value. (Optional)
# Valid values are: [01XZ]
wgl_scan_out_padding = 'X'

# If true, scanchain inverters are ignored while processing scan data. (Optional)
# Valid values are: [01] (false,true)
wgl_skip_inverters = 0


# Purge unused timeplates. (Optional)
# Valid values are: [01] (false,true)
# Remove any unused timeplates from the output file, if true.
wgl_purge_unused_timeplates = 1

# Purge unused waveforms. (Optional)
# Valid values are: [01] (false,true)
# Remove any unused waveforms from the output file, if true.
# Note that unused timeplates will be removed too.
wgl_purge_unused_waveforms = 0

# Export WGL scanchains into STIL ScanStructures. (Optional)
# Valid values are: [01] (false,true)
wgl_export_scanchains = 0

# Add Drive-Off event. (Optional)
# Turn driver off in compare waveforms, if missing
# Valid values are: [01] (false,true)
wgl_add_drive_off = 1

# Allow undefined cell data. (Optional)
# If enabled, undefined cells will be set 
# to default values according to scan direction in/out: N/X
# Valid values are: [01] (false,true)
wgl_allow_undef_cell_data = 0

##############################
# TDL Reader Configuration
######

# Enable/diable scan structures import. (Optional, default = 1)
tdl_import_scan_structures = 1

# If enabled, generate CLOCK signal as 2-edge (RH/RL) instead of 3-edge (SBH/SBL),
# eliminating the first edge. (Optional, default = 0)
tdl_2_edge_clocks = 0

# Purge unused timing data. (Optional)
# Valid values are: [01] (false,true)
# Remove any 'unused' timing timplates/waveforms from the output file, if true.
tdl_purge_unused_timing = 0

# Drive off position. (Optional, default = 0ns)
# Valid values are: absolute times, e.g. '5ns', '2000ps' or reserved keyword 'as_drive_on'
tdl_drive_off_position = ''

# Signal drive off position. (Optional)
# Pin to position map
# Position valid values are: absolute times, e.g. '5ns', '2000ps' or reserved keyword 'as_drive_on'
# tdl_signal_drive_off_position = { 'data' : '2ns'}

##############################
# SVF Reader Configuration
######

# Custom TAP Signals Names
svf_tck  = 'tck' # TCK name
svf_tdi  = 'tdi' # TDI name
svf_tms  = 'tms' # TMS name
svf_trst = 'trst' # TRST name
svf_tdo  = 'tdo' # TDO name

# Timing
svf_tck_freq    = 10000000 # TCK frequency [Hz]
svf_sck_freq    = 10000000 # SCK frequency [Hz]
svf_tset_prefix = 'T' # Default timeset base name

# Timing Edges (defined as timeset period factor)
# clock:
svf_tck_d0 = 0 # drive complement
svf_tck_d1 = 0.25 # drive data [pulse]
svf_tck_d2 = 0.75 # drive complement
# inputs:
svf_in_d1  = 0 # drive data
# outputs:
svf_out_r0 = -1 # driver off
svf_out_r1 = 0.24 # strobe data

# Comments Processing
svf_enable_ds_comments     = 1 # "//" comments enabled
svf_enable_em_comments     = 1 # "!"  comments enabled
svf_generate_tap_comments  = 1 # generate TAP comments
svf_generate_scan_comments = 0 # generate SDI/SDO data comments

# Misc
svf_pio_stop_tck = 0 # stop TCK when PIO command is executed

##############################
# ATE Generator Configuration
######

# Target Platform.(Mandatory)
# Valid values depend on configuration file installed.
# Currently available targets:
#  "93000SS"
#  "NIDigipat"
target = '93000SS'

# Unify WFT periods
# Modify all WFTs to use identical period
#  - scan all WFTs, find GDC of all periods (base period)
#  - split WFTs to use only base period
# Possible values: 0 (disable option) and 1 (enable option), default is 0
unify_periods = 0

# Cycle boundary edge placement (only applicable when unify_periods is enabled)
# Valid values:
# 'next_vector' - insert edge at position 0 of the next vector (default)
# 'curr_vector' - append edge to to the current vector
#unify_periods_boundary_edge_placement = 'next_vector'

# Cycle boundary edge placement for specific signals (only applicable when unify_periods is enabled).
#unify_periods_signal_boundary_edge_placement = { 'Sig1' : 'curr_vector', ... }

# Additional pattern comment.
# This comment will be added to the first vector of all patterns.
pattern_comment = ''

# Default definition files.(Optional)
# Files containing STIL blocks with default definitions.
default_definitions = []

# Overwrite timing file.(Optional)
# File containing STIL with timing definitions overriding those from input file(s).
overwrite_timing = ''

# External data files.(Optional)
# Files containing additional STIL blocks.
external_data_files = []

# STIL PatternExec name. (Optional)
# First one is used if not specified.
stil_pattern_exec = ''

# Pattern naming convention flag ( Optional, default = 1 ).
# If stil_file_name_as_pattern_name = 0, use STIL Pattern name when generating pattern.
# If stil_file_name_as_pattern_name = 1, use STIL File name.
stil_file_name_as_pattern_name = 1

# Project naming convention flag ( Optional, default = 0 ).
# If stil_file_name_as_project_name = 0, use project_name parameter as a base name for signal, timing, levels etc. files.
# If stil_file_name_as_project_name = 1, use STIL File name.
stil_file_name_as_project_name = 0

# Use STIL file name as WFT prefix ( Optional, default = 0 ).
stil_file_name_as_wft_prefix = 0

# Label suffix flag ( Optional, default =  ).
# Add custom suffix to all pattern and burst names
label_suffix = ""

# Set ScanIn signals padding value ( Optional, default = '0' ).
# Only works if no padding value is specified for a scan pin prior to Shift block.
stil_pad_scanin = '0'

# Set ScanOut signals padding value ( Optional, default = 'X' ).
# Only works if no padding value is specified for a scan pin prior to Shift block.
stil_pad_scanout = 'X'

# Scan data padding in ShiftIncremental block ( Optional, default = 0 ).
# If shift_increment_disable_padding = 0, data padding will be done according to Shift processing rules .
# If shift_increment_disable_padding = 1, data padding will not be permitted ( fail with error ).
shift_increment_disable_padding = 0

# Alternative WFC Map. (Optional)
# Define alternative WFC Map for data assignment conflict resolution.
# This map will only be used if native STIL WFCMap fails to resolve a conflict.
# Example: { '0X' : '0', '1X' : '1', ...   }
stil_wfc_map = {
    }

# Global STIL Action Map. (Optional)
# Allows users to globally remap STIL action states in Timing section.
# Example: { 'Z': 'X', 'P': D' }
stil_action_map = { }

# Exit with an error if signal is assigned the value twice in the same vector
# and WFCMap is either absent or does not resolve the ambiguity. (Optional, default is 0).
error_on_2_state_ambiguity = 0

# Force edge strobe ( Optional, default = 0 ).
# If set to 1, STIL window compare events will be replaced with edge compare.
# If set to 0, STIL window compare events will be kept.
force_edge_strobe = 0

# Generate complementary waveforms ( Optional, default = 0 ).
# If set to 1, additional waveforms with "complementary" actions will be generated:
# - for each single-drive   waveform - new ForceUp/Down waveforms
# - for each single-compare waveform - new CompareHigh/Low/Off/Unknown waveforms.
generate_complementary_waveforms = 0

# STIL resource tags handling configuration ( Optional, default = 0 ).
# If ignore_stil_rtags = 0, STIL <rtag> data will be stored and possibly used ( target dependent ).
# If ignore_stil_rtags = 1, STIL <rtag> data will be ignored.
ignore_stil_rtags = 0

# STIL ScanStructures handling configuration ( Optional, default = 1 ).
# If ignore_scan_structures = 0, STIL ScanStructures data will be stored and possibly used ( target dependent ).
# If ignore_scan_structures = 1, STIL ScanStructures data will be ignored.
ignore_scan_structures = 1

# STIL Pseudo Signals handling configuration ( Optional, default = 1 ).
# If stil_ignore_pseudo_signals = 0, Signals of type Pseudo will be processed similar to other signals.
# If stil_ignore_pseudo_signals = 1, Signals of type Pseudo will be ignored.
stil_ignore_pseudo_signals = 1

# Handling of STIL Fixed opcode ( Optional, default = 1 ).
# If fixed_as_breakpoint = 0, Fixed opcode in STIL Patterns will not be treated as Breakpoint.
# If fixed_as_breakpoint = 1, Fixed opcode in STIL Patterns will be treated as Breakpoint.
fixed_as_breakpoint = 1


# Output directory. (Optional, default = 'output')
workdir = 'stil_with_dc'

# Project name. (Optional, default = 'project' )
# Serves as a base name for all named TP blocks
project_name = 'stil_with_dc'

# Ignore free-running clock signals in patterns ( Optional, default = 0 ).
ignore_free_running_clocks_in_patterns = 0

# Pattern signals definition. (Optional)
# Both signals and signal groups alowed.
# Wildcards allowed ( only '?' and '*' supported ).
# Define a reduced set signals to be used in the pattern only.
# Signals not in the list will still appear in 'workspace' portion
# of the test program.
# Example: [ 'sig1', 'sig2', 'sigN' ]
pattern_signals = [  ]

# Define global signals set. (Optional)
# Both signals and signal groups alowed.
# Wildcards allowed ( only '?' and '*' supported ).
# Only specified signals will be passed to the target test program.
# This parameter is mutually exclusive with 'exclude_signals'.
# Example: [ 'sig1', 'sig2', 'sigN' ]
include_signals = [  ]

# Define set of signals to exclude from target test program. (Optional)
# Both signals and signal groups alowed.
# Wildcards allowed ( only '?' and '*' supported ).
# Specified signals will be completely removed from the target test program.
# This parameter is mutually exclusive with 'include_signals'.
# Example: [ 'sig1', 'sig2', 'sigN' ]
exclude_signals = [  ]

# Rename signals. (Optional)
# Define a mapping between simulation signals and target ATE pins.
# Any signals not specified in the map will use original names.
# Signal groups are not allowed.
# Note: this will not affect any signal-related configuration settings above,
#       i.e. all signal-related setup variables should always refer to the original signal names.
# Example: { 'signal_name1' : 'ATE_signal_name1', 'signal_name2' : 'ATE_signal_name2', ...   }
rename_signals = {
    }

# Stop on uninitialized signals ( Optional, default = 0 ).
stop_on_uninitialized_signals = 0

# Rename WFTs. (Optional)
# Define a mapping between simulation WFTs and target ATE WFTs.
# Example: { 'WFT1' : 'ATE_WFT1', 'WFT2' : 'ATE_WFT2', ...   }
rename_wfts = {
    }

# Timing Map. (Optional)
# Define STIL timing mapping in order to fit to tester restrictions.
# For example, map all dual compare waveforms to single compare.
# By default all inputs with undefined value are mapped to 0.
# The following wildcards can be used:
#     I for input  events - D, U, P, A, B
#     O for output events - H, L, X, x, T, V, l, h, t, v
#     . for any event.
# Example: { 'N' : 'D' }
timing_map = {
    'N': 'D',
    }

# Signal Timing Map. (Optional)
# Define STIL timing mapping for specific signals.
# By default global timing map is used.
# Wildcards can be used (same as in Timing Map).
# Example: { 'STIL_signal_name1' : { 'UDU' : '-DU' , 'DUD' : '-UD' , ... } , ... }
signal_timing_map = {
    }

# Sequence Map. (Optional)
# Define pattern states mapping for specific signals.
# Valid values are 0/1/Z/L/H/T/X.
# Example: { 'signal_name1' : { '010' : '111' , 'LHL' : 'LXL' , ... } , ... }
sequence_map = {
    }

# Equation Based Timing. (Optional, default = 1)
# Generate equation (Spec) based timing if original timing only used absolute values without any Spec definition.
# For example, equation specified as 10ns (when period is 100ns)
# will become 0.1*per_100, where per_100 is a new Spec variable.
equation_based_timing = 1

# Frequency Based Timing. (Optional, default = 0)
# Relevant only if Equation Based Timing is on.
# If set to 0, timing equations will be based on period.
# If set to 1, timing equations will be based on frequency.
frequency_based_timing = 0

# Optimize Spec Variables in Equation Based Timing Mode. (Optional, default = 1)
# If optimize_equation_based_timing_vars = 1, a spec variable for each unique WFT period will be generated (e.g. per_100).
# If optimize_equation_based_timing_vars = 0, a spec variable for each WFT will be generated (e.g. per_SHIFT, per_CAPTURE).
optimize_equation_based_timing_vars = 1

# Vector Comment Source. ( Optional, default = ['Annotation'] )
# Vector comment is placed before the vector call in the vector comment field, as follows:
# 'Annotation' use the content of the annotation block ( Ann {* .. *} )
# 'C' use the content of the C comment ( /* .. */ )
# 'C++' use the content of the C++ comment ( // ... )
# 'Macro' Places name of Macro called in the vector comment field
# 'Procedure' Places name of Procedure called in the vector comment field.
# 'Scan Instance' Places the scan instance in the vector comment field (i.e. the number of times the Shift
#                 statement has been called in the context of a Pattern block)
# 'Label' Places STIL Label name in the vector comment field
#  Note: more the one comment type may be defined, as follows: [ 'C', 'C++', 'Macro' ]
vector_comment_source = [ 'C++', 'C', 'Annotation' ]

# Same line comment handling. ( Optional, default = 0 )
# If set to 1, attach comment to the vector at the same line.
# If set to 0, attach it to the next vector
same_line_comment = 0

# Define set of scan cells to mask. (Optional)
# Example: [ 'cell1', 'cell2', 'cellN' ]
mask_scan_cells = [  ]

# Define set of scan chains to mask. (Optional)
# Example: [ 'chain1', 'chain2', 'chainN' ]
mask_scan_chains = [  ]

# Define set of scan signals to mask. (Optional)
# Example: [ 'sig1', 'sig2', 'sigN' ]
mask_scan_signals = [  ]

# Scan pattern start label. (Optional, default = '')
# Generation of scan pattern will start from this label.
# If empty, generation starts at the start of the pattern.
scan_pattern_start = ''

# Scan pattern stop label. (Optional, default = '')
# Generation of scan pattern will stop at this label.
# If empty, generation stops at the end of the pattern.
scan_pattern_stop = ''

# Generate pattern from specified cycle value (Optional, default = 1 ).
cycle_start = 1

# Generate pattern until specified cycle value (Optional, default = -1 <end of pattern>).
cycle_end = -1

# Skip non-indexed multibit events. (Optional, default = 1)
# In multibit waveforms, use only indexed events when creating wfc sequence.
# For example, waveform "eE {'0ns' D/U[0]; '2.5ns' Z; }"
# should be referred in pattern as e or E (if parameter is set to 1).
# or as ee or Ee (if parameter is set to 0).
skip_nonindexed_events = 1

# Define set of user keywords to be processed. (Optional)
# The following keywords can be specified:
# 'ShiftIncrement'   : similar to Shift, but if contains multiple vectors, data is shifted after each vector
# 'InfiniteLoop'     : handled as non-looped sequence of vectors
# 'FreeRunning'      : defines async free-running clock
# 'DifferentialInvOf': name of the positive diff. pin
# 'BitAlignment'     : 1149-10 bit alignment
# 'LatencyAlignment' : 1149-10 latency alignment
# 'MatchAttrs'       : match loop custom attrs
# Example: [ 'kwd1', 'kwd2' ]
process_user_keywords = [  ]

# Define custom set of user keywords. (Optional)
# This definition is equivalent to the native STIL UserKeywords statement
# Example: [ 'kwd1', 'kwd2' ]
user_keywords = [  ]

# Generate pins ( Optional, default = 1 ).
# If set to 1, ATE pin definitions will be generated.
# If set to 0, ATE pin generation will be skipped ( target dependent ).
generate_pins = 1

# Generate timing ( Optional, default = 1 ).
# If set to 1, ATE timing definitions will be generated.
# If set to 0, ATE timing generation will be skipped ( target dependent ).
generate_timing = 1

# Generate levels ( Optional, default = 1 ).
# If set to 1, ATE DC levels definitions will be generated.
# If set to 0, ATE DC levels generation will be skipped ( target dependent ).
generate_levels = 1

# Generate patterns ( Optional, default = 1 ).
# If set to 1, ATE patterns will be generated.
# If set to 0, ATE patterns generation will be skipped ( target dependent ).
generate_patterns = 1

# Generate ( Optional, default = 1 ).
# If set to 1, ATE workspace will be generated.
# If set to 0, ATE workspace generation will be skipped ( target dependent ).
generate_workspace = 1

# STIL reader mode.(Optional)
# Valid values are: one_pass two_pass
stil_reader_mode = 'one_pass'

# STIL Editor setup file.(Optional)
stil_editor_setup = ''

############################
# Virtual Signal Generation
#

# Define virtual signals ( optional ).
#  Attributes:
#   name:	 virtual signal name ( mandatory, must be unique )
#   type:	 virtual signal type ( optional, one of [ In | Out | InOut ] )
#   opcode:	 virtual signal operator ( mandatory )
#     'Fixed':            Fixed state signal ( arg1 = state [DUZLHXT], arg2 = time )
#     'Copy':             Copy reference signal ( arg1 = ref. signal name )
#     'Not':              Copy reference signal, inverting states ( arg1 = ref. signal name )
#   args:	 operator attributes ( depend on 'op' selected )
#
# virtual_signals = [ 
#   { 'name': 'sig_name', 'type': 'sig_type', 'opcode': 'opcode', 'args': [ 'arg1', 'arg2' ...] },
#   { 'name': 'sig_name', 'type': 'sig_type', 'opcode': 'opcode', 'args': [ 'arg1', 'arg2' ...] } ...
# ]

##################################
# 93000SS flags 
######

# Controls output behavior depending on SmarTest version
ss_smartest_version = "7.1.0"

# Tester model selection.
# 'PS400', 'PS800' and 'PS3600' are valid models for 93000DD.
# 'P1000', 'P800', 'P600', 'C400e' and 'C200e' are valid models for 93000SD.
# 'PS9' and 'PS1600' are valid models for 93000SS.
ss_tester_model = "PS1600"

# Path to the combinations file.
# Combinations file is used for incremental generation of multiple patterns.
# When set, ATEGen will store timing and Xmode combinations information
# in this file in order keep the timing compatible with all generated patterns.
# Recommended when Xmode factor is applied.
ss_combinations_file = None

# Generate additional mode contexts (for use with ViperSL card)
ss_generate_mode_contexts = []

# Select mode context to use in the timing, levels and patterns
ss_use_mode_context = None

# Enables or disables the use of absolute paths in EQFS commands
ss_absolute_paths = 0

# Device cycle naming customization.
# The keys are <WFT>_<WFC> strings, the values are user-defined device cycles.
# Example:
# dd_dcdf_remapping = { 'SHIFT_L' : 'L', 'SHIFT_H' : 'H' }
ss_dcdf_remapping = {}

# Device cycle naming for specific signals.
# The keys are signal names,
# the values are tables with <WFT>_<WFC> strings as keys,
# mapped to user-defined device cycles.
# Example:
# dd_dcdf_signal_remapping = { 'SCANOUT0' : {  'SHIFT_L' : 'L', 'SHIFT_H' : 'H' }, 
#                              'SCANOUT1' : {  'SHIFT_L' : 'P', 'SHIFT_H' : 'C' } }
ss_dcdf_signal_remapping = {}

# Wavetable naming customization.
# The keys are <WFT1>_<WFT2>_... strings for regular setups,
# and <WFT1>_<WFT2>_...<PORT> strings for multiport setups,
# the values are user-defined strings.
# Example:
# dd_wavetbl_remapping = { 'default_load_unload' : 'WVT1' }
ss_wavetbl_remapping = {}

# Device vector variable naming for digital capture.
# The keys are the original vector variable names,
# mapped to user-defined names.
# Example:
# dd_dcap_vector_variable_rename = { 'DF1_P1' : 'MyVar1', 'DF1_P2' : 'MyVar2'}
ss_dcap_vector_variable_rename = {}

# Enable or disable GZip compression of vector files.
ss_gzip_patterns = 0

# Compress identical vectors to single vector loops
ss_repeat_compression = 0

# When repeat compression is on: compress identical vectors to single vector loops although they don't have the same comment.
# The different comments from the vectors will be placed before the created loop.
ss_repeat_compression_ignore_comments = 1

# Enable or disable WFC ordering as in source STIL file
ss_keep_wfc_order = 0

# This option is reserved for future use and should not be modified
ss_max_vector_buffer = 158928

# Data size for a single BCMT vector comment command
ss_comment_max_size = 640000

# Error out on comments violating SmarTest limit (depends on SmarTest version).
# If disabled, long comments are truncated and a warning is generated.
ss_error_on_long_comments = 0

# If all comments for all sub-Xmode vectors are identical generate only single comment, when each comment separated by '|'.
ss_xmode_aware_comments = 0

# Loops will be flattened if loop count is less than repeat break value.
# Loops will be flattened by default if (loop_size * loop_count + 6)/7 < 1 + (loop_count + 6)/7
ss_repeat_break = None

# Expand original loops in source STIL files
ss_expand_loops = 0

# Generate ASCII pattern (AVC) and TMF files
ss_generate_ascii_pattern = 0

# Generate ASCII TMF file only
ss_generate_ascii_tmf = 0

# Use ASCII pattern state hook.
# The hook should accept the following parameters: pin,wft,wfc,default_state
# and should return the new state. E.g.:
# def avc_state(pin,wft,wfc,default_state):
# new_state = ...
# return new_state
ss_ascii_pattern_state_hook = None

# Allow duplication of ASCII states produced by user-defined hook
ss_ascii_pattern_state_hook_allow_duplication = 0

# Add STIL information as comments to timing files
ss_tim_comments = 1

# Add tool version and generation date as comments to timing files
ss_tim_header_comments = 1

# Use EQFS commands in timing and level files
ss_use_eqfs = 0

# Don't create signal group definitions if those groups are not used in timing and level declarations in STIL
ss_skip_unused_signal_groups = 0

# Allow unify periods
ss_allow_unify_periods = 0

# Enable or disable group definitions in timing files
ss_use_tim_groups = 1

# Generate timing based on pin names and without the use of pin groups if selected.
ss_pin_based_tim = 0

# Exclude pins from grouping in timing files
ss_tim_group_exclude_pins = []

# Pattern memory type.
# Valid pattern memory types are:
# 'VM'    for SmarTest versions until 7.0.0
# 'SM'    for all SmarTest versions
# 'SHMEM' for SmarTest versions 7.0.1 and higher
# 'auto'  for automatic selection of memory type according to SmarTest version
ss_pattern_memory_type = "auto"

# This option is reserved for future use and should not be modified
ss_use_vecc = 1

# Apply Xmode factor to all patterns.
# The value of Xmode factor should be an integer or "auto"
# to apply maximum possible Xmode factor.
# Maximum possible Xmode factor is calculated based on actual timing and vector combinations
ss_xmode_factor = 1

# Enable or disable all possible Xmode combinations in timing instead
# of only actual timing combinations in the patterns.
# Use with caution - may lead to waveformtable overflow
ss_xmode_all_cmb = 0

# Allow addition of new waveforms in combinations file
ss_combinations_allow_new_waveforms = 1

# Allow addition of new break waveforms in combinations file
# (to allow, both this and dd_combinations_allow_new_waveforms must be set to 1)
ss_combinations_allow_new_break_waveforms = 0

# Allow combinations file update.
# Setting to 0 will disable both dd_combinations_allow_new_waveforms and
# dd_combinations_allow_new_break_waveforms
ss_allow_combinations_file_update = 1

# Pad last xmode vector.
# Padding is performed when the number of vectors in not evenly divisible by xmode factor and if the last waveform contains only drive actions.
ss_pad_xmode_vectors = 0

# Align patterns execution time considering xmodes.
ss_align_xmode_patterns = 0

# Apply BFLM alignment to patterns
ss_bflm_mode = 0

# Repeat count for wait vectors in BFLM match loop
ss_bflm_match_repeat_count = 0

# Receive edge optimization.
# Compare don't care and window close edges are removed, if not needed or duplicated.
ss_optimize_receive_edges = 1

# Drive edge optimization.
# Repeated drives of the same values are removed and edges are downgraded in order not to require tristate capable edges.
ss_optimize_drive_edges = 1

# Allow wavetable merge, to optimize tester resources
ss_allow_wavetbl_merge = 0

# Generate single port timing, if possible
ss_single_port_timing = 0

# Default port name. If different than '@', all pins will be assigned to
# the specified port and multiport timing and pattern will be generated
ss_default_port = "@"

# Enable or disable default break waveform generation.
ss_create_default_break_waveforms = 0

# Allow use of CTIM, only compatible with X1 and single port
ss_allow_ctim = 0

# Print cycle and vector numbers
ss_cycle_numbering = 0

# Create all_inputs and all_outputs signal groups for debug purposes
ss_auto_create_signal_groups = 1

# Use specific channel mapping from STIL Environment block
ss_use_channel_mapping = None

# Import model file. Model file is used for the following:
# Assign or validate channel numbers for pin configuration generation.
# Verify that patterns do not violate memory license settings.
# In case of memory license violation warnings will be issued.
ss_use_model_file = None

# Enable or disable creation of code that is not loadable
ss_strict_mode = 0

# Enable or disable default values for DC levels, if not all levels are specified
ss_allow_default_levels = 1

# Print information about signals using default levels
ss_default_levels_summary = 0

# Group definitions in levels files.
ss_use_lvl_groups = 1

# Exclude pins from grouping in level files
ss_levels_group_exclude_pins = []

# Enable or disable the use of MHz frequency in AC specs
ss_use_mhz_specs = 0

# Keep unused specsets
ss_keep_all_specsets = 0

# Keep unused AC and DC variables
ss_keep_spec_variables = 0

# Creates a separate SPECSET for Typ, Min and Max AC and DC spec values. This allows to run the same test with Typ, Min or Max selectors
ss_create_min_max_typ_tests = 0

# Enable or disable printing full incremental mode report
ss_full_incremental_log = 0

# Enable or disable timing files with Statemapping information
ss_create_statemapping = 0

# Enable or disable Statemapping based on selected Xmode
ss_xmode_based_statemapping = 1

# Statemapping selector name.
# The default is the value of project_name parameter
ss_statemap_selector = ""

# Create separate ports for scan and non-scan signals
ss_scan_multiport = 0

# Create separate ports for stable and non-stable signals
ss_stable_multiport = 0

# For multiple inputs, instead of generating a separate test suite for each input
# generate a single one calling patterns from all inputs
ss_single_test_suite = 0

# Enable or disable scan diagnostics
ss_generate_vmap = 0

# HVM support. Generates VCAT pattern command
ss_generate_hvm = 0

# HVM vector and cycle information
ss_hvm_cycle_info = 0

# Generate HVM diagnostics based on shift outs
ss_hvm_shift_out_patterns = 0

# Support for Synopsys TetraMAX scan diagnostics
ss_tetramax_scan_diagnostics = 0

# Yield learning (Nautilus) support
ss_yield_learning = 0

# Yield learning - scan structures selection
ss_yield_learning_scan_structures = None

# Yield learning - scan structures domain name used in protocol file
ss_yield_learning_scan_domain = None

# Yield learning - skip flops
ss_yield_learning_skip_flops = 0

# Support multiple clock domains
ss_generate_clksets = 0

# Print vector usage summary for each binary pattern
ss_vector_memory_summary = 0

# Allow match loops with number of vectors not aligned to xmode
ss_allow_nonaligned_match_loops = 0

# Testmethod mode, may be 'utm','classic' or 'functions'
ss_testmethod_mode = "utm"

# Testmethod name, used in classic mode only
ss_testmethod_name = ""

# Testmethod parameters, used in UTM and classic modes
ss_testmethod_params = ""

# Testmethod limits, used in UTM and classic modes
ss_testmethod_limits = ""

# Testmethod class, used in UTM and classic modes. The default suits only UTM mode, please replace it with 'functional' for classic mode
ss_testmethod_class = "ac_tml.AcTest.FunctionalTest"

# Choose SmarTest capture mode between 'std_selective' or 'HRPF'
ss_digital_capture_mode = "std_selective"

# Choose smartest capture resolution between 'std' or 'double'
ss_digital_capture_res = "std"

# PS9G signals list
ss_ps9g_signals = []

# High voltage signals list
ss_high_voltage_signals = []

# Protocol engine signals
ss_protocol_engine_signals = []

